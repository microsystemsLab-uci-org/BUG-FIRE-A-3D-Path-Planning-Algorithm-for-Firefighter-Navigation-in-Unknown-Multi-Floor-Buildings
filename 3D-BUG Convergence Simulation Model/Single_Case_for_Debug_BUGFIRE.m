clear all; close all; clc;

%% Libraries
% Specifications Peter's Coke BUG2 Implementation:
% https://www.petercorke.com/RTB/r9/html/Bug2.html
currentFolder = pwd;
addpath(genpath('C:\Users\Eudald\Documents\Git Repos\PeterCork_PathPlanning_Lib\rtb'));
addpath(genpath('C:\Users\Eudald\Documents\Git Repos\PeterCork_PathPlanning_Lib\common'));
addpath(genpath('C:\Users\Eudald\Documents\Git Repos\PeterCork_PathPlanning_Lib\smtb'));
addpath(genpath([currentFolder, '\MAE_Occupancy_Map']));
addpath(genpath([currentFolder, '\lib\Plots']));
addpath(genpath([currentFolder, '\lib\Navigation']));

% Get the screen size
screenSize = get(0, 'ScreenSize');
% Calculate 90% of the screen width and height
width = round(screenSize(3) * 0.9);
height = round(screenSize(4) * 0.8);

% Calculate the left and bottom coordinates to center the figure
left = round((screenSize(3) - width) / 2);
bottom = round((screenSize(4) - height) / 2);

%% Import EG Map
tStart = tic;   
% Generate the Engineering Gateway 3D map
maps = generateEGMap3DBUG();
tEnd = toc(tStart);
disp("Time Elapsed Plotting EG Map: " + num2str(tEnd))

% Hold the current figure to allow overlaying additional plots
figureHandle = findobj('Type', 'Figure', 'Name', '3D Trajectory MAE UCI');
set(figureHandle, 'Position', [left, bottom, width, height]);
if isempty(figureHandle)
    error('The figure generated by generateEGMap3DBUG does not exist. Ensure the function has executed correctly.');
end

%% Initial Parameters:
scenario = 28;
switch scenario
    % Case BUG2 same floor Target
    case 1
        startHeight = 0;                       % 0 - 2nd Floor , 100 - 3rd Floor , 200 - 4th Floor 
        startPoint  = [15, 144, startHeight];  % X, Y: define the start point
        goalHeight = 0;                       % 0 - 2nd Floor , 100 - 3rd Floor , 200 - 4th Floor
        goalPoint  = [85, 312, goalHeight];   % X, Y: define the goal point
    % Case EExit found earlier than projected target
    case 2
        startHeight = 0;                 
        startPoint  = [15, 144, startHeight];  
        goalHeight = 100; % Target Reached
        goalPoint  = [48, 250, goalHeight];   
    case 3
        startHeight = 0;                 
        startPoint  = [15, 144, startHeight];  
        goalHeight = 200; % Target Not Reached
        goalPoint  = [48, 250, goalHeight];   
    case 4
        startHeight = 0;                 
        startPoint  = [15, 144, startHeight];  
        goalHeight = 100;               % 0 - 2nd Floor , 100 - 3rd Floor , 200 - 4th Floor
        goalPoint  = [85, 165, goalHeight];   
    case 5
        startHeight = 0;                 
        startPoint  = [15, 144, startHeight];  
        goalHeight = 200;               
        goalPoint  = [85, 165, goalHeight];   
    case 6
        startHeight = 0; 
        startPoint  = [45, 28,  startHeight];  %80, 74,
        goalHeight = 200;               
        goalPoint  = [85, 165, goalHeight];
    case 7
        startHeight = 100; 
        startPoint  = [82, 74, startHeight];  
        goalHeight = 0;               
        goalPoint  = [85, 165, goalHeight];
    case 8
        startHeight = 0; 
        startPoint  = [84, 31, startHeight];  
        goalHeight = 200;               
        goalPoint  = [85, 165, goalHeight];
    case 9
        startHeight = 0; 
        startPoint  = [92, 107, startHeight];  
        goalHeight = 200;               
        goalPoint  = [85, 165, goalHeight];
    case 10
        startHeight = 0; 
        startPoint  = [96, 165, startHeight];  
        goalHeight = 200;               
        goalPoint  = [85, 165, goalHeight];
    case 11
        startHeight = 0; 
        startPoint  = [83, 281, startHeight];  
        goalHeight = 200;               
        goalPoint  = [82, 300, goalHeight]; 
    case 12
        startHeight = 0; 
        startPoint  = [43, 120, startHeight];  
        goalHeight = 200;               
        goalPoint  = [82, 300, goalHeight];
    case 13
        startHeight = 100; 
        startPoint  = [97, 164, startHeight];  
        goalHeight = 100;               
        goalPoint  = [88, 164, goalHeight];
    case 28 % Real-Example with ML2-AR 1
        startHeight = 0; 
        startPoint  = [58, 92, startHeight];  
        goalHeight = 100;               
        goalPoint  = [58, 170, goalHeight];
    case 29 % Real-Example with ML2-AR 2
        startHeight = 0; 
        startPoint  = [84, 236, startHeight];  
        goalHeight = 100;               
        goalPoint  = [84, 236, goalHeight];
    case 30 % Real-Example with ML2-AR 3
        startHeight = 100; 
        startPoint  = [86, 44, startHeight];  
        goalHeight = 0;               
        goalPoint  = [56, 171, goalHeight];
end

visionRadius = 30;
visionAngle = 170;

%% Compute & Display the 3D m-line
load('MAE_Occupancy_Map/EG-2Floor_indoor_polygon_MC_Simulation.mat');
load('MAE_Occupancy_Map/EG-2Floor_Hole1_indoor_polygon_MC_Simulation.mat');
load('MAE_Occupancy_Map/EG-2Floor_Hole2_indoor_polygon_MC_Simulation.mat');
load('MAE_Occupancy_Map/EG-2Floor_Hole3_indoor_polygon_MC_Simulation.mat');
load('MAE_Occupancy_Map/EG-3Floor_indoor_polygon_MC_Simulation.mat');
load('MAE_Occupancy_Map/EG-4Floor_indoor_polygon_MC_Simulation.mat');
% Apply translation to the third floor polygon
thirdFloorPolygon = EG_3Floor_indoor_polygon_MC_Simulation(:, [2, 1]);
thirdFloorPolygon(:, 1) = thirdFloorPolygon(:, 1) + 39;  % Add 36 to x-coordinates
% Apply translation to the third floor polygon
fourthFloorPolygon = EG_4Floor_indoor_polygon_MC_Simulation(:, [2, 1]);
fourthFloorPolygon(:, 1) = fourthFloorPolygon(:, 1) + 37;  % Add 36 to x-coordinates
% Swap x and y coordinates for all polygons
secondFloorPolygon = EG_2Floor_indoor_polygon_MC_Simulation(:, [2, 1]);
holes = {
    EG_2Floor_Hole1_indoor_polygon_MC_Simulation(:, [2, 1]),
    EG_2Floor_Hole2_indoor_polygon_MC_Simulation(:, [2, 1]),
    EG_2Floor_Hole3_indoor_polygon_MC_Simulation(:, [2, 1])
};
% Combine polygons into a cell array
polygons = {
    {0, secondFloorPolygon, holes},
    {100, thirdFloorPolygon},
    {200, fourthFloorPolygon}
};
colors = [1 0.4 0.4; 1 0.6 0.6; 1 0.8 0.8]; % Different shades of red for each floor

        
figure(figureHandle);
hold on;
for i = 1:length(polygons)
        floorHeight = polygons{i}{1};
        polygon = polygons{i}{2};
        
        % Create a slightly elevated plane for better visibility
        z = ones(size(polygon, 1), 1) * (floorHeight);
        
        % Plot the polygon as a filled area
%         fill3(polygon(:,1), polygon(:,2), z, colors(i,:), 'FaceAlpha', 0.5);
        
        % Plot the polygon outline
%         plot3(polygon(:,1), polygon(:,2), z, 'k-', 'LineWidth', 2);
        
        % Plot holes for 2nd floor
        if i == 1
            for j = 1:length(holes)
                hole = holes{j};
                z_hole = zeros(size(hole, 1), 1) + floorHeight +0.1;
%                 fill3(hole(:,1), hole(:,2), z_hole, 'w-', 'LineWidth', 3);
            end
        end
    end

mLine3D  = homline(startPoint (1), startPoint (2), goalPoint(1), goalPoint(2)); % Calculate the homogeneous line representation of the m-line
mLine3D  = mLine3D  / norm(mLine3D (1:2)); % Normalize the line

% Get the current axis limits
axisLimits = axis;
xMin = axisLimits(1); xMax = axisLimits(2);
yMin = axisLimits(3); yMax = axisLimits(4);

% Plot 3D m-line
figure(figureHandle); % Bring the existing figure to the foreground
hold on;

% 2D and 3D M-Line representation
if startHeight == goalHeight 
    % If start and goal are on the same floor
    if mLine3D (2) == 0
        % If the line is vertical (infinite slope)
        plot3([startPoint(1) startPoint(1)], [yMin yMax], [startHeight goalHeight], '--', 'Color', '#696969','LineWidth',2);
    else
        % For non-vertical lines
        x = [xMin xMax]';
        y = -[x [1;1]] * [mLine3D(1); mLine3D(3)] / mLine3D(2);
        plot3(x, y, [goalHeight; goalHeight], '--', 'Color', '#696969', 'Linewidth',2);
        axis equal
    end
else
    % If start and goal are on different floors
    x_proj = linspace(startPoint(1), goalPoint(1), 100);
    y_proj = linspace(startPoint(2), goalPoint(2), 100);
    z_proj = startHeight * ones(size(x_proj));

    x = [xMin xMax]';
    y = -[x [1;1]] * [mLine3D(1); mLine3D(3)] / mLine3D(2);

    % 1. Plot the horizontal projection on the start level
    plot3(x, y, [startHeight; startHeight], '-.', 'Color', '#A0A0A0', 'Linewidth', 2, 'DisplayName', 'Horizontal Projection');

    % 2. Plot the 3D m-line from start to goal
    zLine = linspace(startHeight, goalHeight, 100);
    plot3(x_proj, y_proj, zLine, '-', 'Color', '#696969', 'Linewidth', 2, 'DisplayName', '3D m-line');

    % 3. Plot the vertical line from (goal_x, goal_y, start_z) to (goal_x, goal_y, goal_z)
    plot3([goalPoint(1), goalPoint(1)], [goalPoint(2), goalPoint(2)], [startHeight, goalHeight], '-.', 'Color', '#696969', 'Linewidth', 2, 'DisplayName', 'Vertical Line');
end

% Plot Initial Position on the 3D plot:
plot3(startPoint (1), startPoint (2), startHeight, 'ko', 'MarkerSize', 6, 'MarkerEdgeColor', 'k', 'MarkerFaceColor', 'g');
% Plot the Final Position on the 3D Plot:
plot3(goalPoint(1), goalPoint(2), goalHeight, 'p', 'MarkerSize', 8, 'MarkerFaceColor', 'r', 'MarkerEdgeColor', 'k');


%% 3D BUG algorithm:
tStart = tic;
total_path = [];
trajectory_length = 0;
% If the startHeight is the same as the goalHeight:
while true
    if startHeight == goalHeight
        switch startHeight
            case 0
                bug = Bug2_ES(maps.grid.floor2);      % create navigation object
            case 100
                bug = Bug2_ES(maps.grid.floor3);      % create navigation object
            case 200
                bug = Bug2_ES(maps.grid.floor4);      % create navigation object
        end
        pause(1);
        fig = figure;
        set(fig, 'Position', [left, bottom, width, height]);
        [path, goalReached] = bug.query(startPoint(1:2), goalPoint(1:2), 'animate', true); % animate the path from start to goal
%         [path, goalReached] = bug.query(startPoint(1:2), goalPoint(1:2), 'movie', 'bug2_navigation.mp4');
        total_path = vertcat(total_path, path);

        % Calculate differences between consecutive points
        diff_path = diff(path);
        
        % Calculate Euclidean distance for each step
        step_distances = sqrt(sum(diff_path.^2, 2));
        
        % Sum up all distances to get total trajectory length
        trajectory_length = trajectory_length + sum(step_distances)/4;
        % Display the result
        fprintf('The estimated trajectory length in 2D bug is approximately %.2f m.\n', sum(step_distances)/4);
        fprintf('The total estimated trajectory length is approximately %.2f m.\n', trajectory_length);

        if ~isempty(path)
            figure(figureHandle); % Bring the existing figure to the foreground
            hold on;
            switch startHeight
                case 0
                    plot3(path(:,1), path(:,2), ones(size(path,1), 1)*0, 'g-', 'LineWidth', 2);
                case 100
                    plot3(path(:,1), path(:,2), ones(size(path,1), 1)*100, 'g-', 'LineWidth', 2);
                case 200
                    plot3(path(:,1), path(:,2), ones(size(path,1), 1)*200, 'g-', 'LineWidth', 2);
                otherwise
                    hold off; % Release the hold
            end
        end
        
        if goalReached == false
            disp("Robot is trapped, we coudn't find a reachable path to the target.")
            tEnd = toc(tStart);
            disp("Time Elapsed to implement the 3D Bug algorithm: " + num2str(tEnd))
            break;
        else
            disp("Target found!")
            tEnd = toc(tStart);
            disp("Time Elapsed to implement the 3D Bug algorithm: " + num2str(tEnd))
            break;
        end % else
    end
    % If the startHeight is different form the goalHeight:
    if startHeight ~= goalHeight
        % BUG3 Algorithm here!
        switch startHeight
            case 0
                bug = emergencyExitExploration_ES(maps.grid.floor2);      % create navigation object
                bug.setSignCellsDirection([maps.emergencySigns.floor2.direction(:)]);
                bug.setSignCellsLocation([maps.emergencySigns.floor2.location(1,:)', maps.emergencySigns.floor2.location(2,:)',]); 
                bug.setExitCells([maps.emergencyStairs.floor2(1,:)', maps.emergencyStairs.floor2(2,:)']); % Stop cells - Emergency stair: Indoor & Outdoor [x',y']
            case 100
                bug = emergencyExitExploration_ES(maps.grid.floor3);      % create navigation object
                bug.setSignCellsDirection([maps.emergencySigns.floor3.direction(:)]);
                bug.setSignCellsLocation([maps.emergencySigns.floor3.location(1,:)', maps.emergencySigns.floor3.location(2,:)',]); 
                bug.setExitCells([maps.emergencyStairs.floor3(1,:)', maps.emergencyStairs.floor3(2,:)']); % Stop cells - Emergency stair: Indoor & Outdoor [x',y']
            case 200
                bug = emergencyExitExploration_ES(maps.grid.floor4);      % create navigation object
                bug.setSignCellsDirection([maps.emergencySigns.floor4.direction(:)]);
                bug.setSignCellsLocation([maps.emergencySigns.floor4.location(1,:)', maps.emergencySigns.floor4.location(2,:)',]); 
                bug.setExitCells([maps.emergencyStairs.floor4(1,:)', maps.emergencyStairs.floor4(2,:)']); % Stop cells - Emergency stair: Indoor & Outdoor [x',y']
        end
        
        fig = figure;
        set(fig, 'Position', [left, bottom, width, height]);
%         [path, goalReached, exitStairsNumber] = bug.query(startPoint, goalPoint, 'animate', true);  % Run the pathfinding with vision cone
        [path, goalReached, exitStairsNumber] = bug.query(startPoint, goalPoint, 'animate', true, 'visionRadius', visionRadius, 'visionAngle', visionAngle);  % Run the pathfinding with vision cone
%         [path, goalReached, exitStairsNumber] = bug.query(startPoint, goalPoint, 'movie', 'bugEmergencyExitExploration.mp4');

        total_path = vertcat(total_path, path);
                % Calculate differences between consecutive points
        diff_path = diff(path);
        
        % Calculate Euclidean distance for each step
        step_distances = sqrt(sum(diff_path.^2, 2));
        
        % Sum up all distances to get total trajectory length
        trajectory_length = trajectory_length + sum(step_distances)/4;
        % Display the result
        fprintf('The estimated trajectory length during emergency stairs exploration is approximately %.2f m.\n', trajectory_length);

        % Plot the path trajectory in green at Fig 1
        if ~isempty(path)
            figure(figureHandle); % Bring the existing figure to the foreground
            hold on;
            switch startHeight
                case 0
                    plot3(path(:,1), path(:,2), ones(size(path,1), 1)*0, 'g-', 'LineWidth', 2);
                case 100
                    plot3(path(:,1), path(:,2), ones(size(path,1), 1)*100, 'g-', 'LineWidth', 2);
                case 200
                    plot3(path(:,1), path(:,2), ones(size(path,1), 1)*200, 'g-', 'LineWidth', 2);
                otherwise
                    hold off; % Release the hold
            end
        end

        % Important, organize exitStairsNumber such as the emergency exits
        % that go across all floors (in the generateEGMap3DBUG function)
        if exitStairsNumber == 1 || exitStairsNumber == 2 || exitStairsNumber == 3
            startHeight = goalHeight;
        end

        switch startHeight
            case 0
                if exitStairsNumber > 0 && exitStairsNumber <= size(maps.emergencyStairs.floor2, 2)
                    startPoint = [maps.emergencyStairs.floor2(:, exitStairsNumber)', startHeight];
                else
                    error("Invalid exitStairsNumber: %d. Ensure emergency stairs logic is correct.", exitStairsNumber);
                end
            case 100
                if exitStairsNumber > 0 && exitStairsNumber <= size(maps.emergencyStairs.floor3, 2)
                    startPoint = [maps.emergencyStairs.floor3(:, exitStairsNumber)', startHeight];
                else
                    error("Invalid exitStairsNumber: %d. Ensure emergency stairs logic is correct.", exitStairsNumber);
                end
            case 200
                if exitStairsNumber > 0 && exitStairsNumber <= size(maps.emergencyStairs.floor4, 2)
                    startPoint = [maps.emergencyStairs.floor4(:, exitStairsNumber)', startHeight];
                else
                    error("Invalid exitStairsNumber: %d. Ensure emergency stairs logic is correct.", exitStairsNumber);
                end
        end
    end
end


% Hold the current figure to allow overlaying additional plots
figureHandle = findobj('Type', 'Figure', 'Name', '3D Trajectory MAE UCI');
if isempty(figureHandle)
    error('The figure generated by generateEGMap3DBUG does not exist. Ensure the function has executed correctly.');
end

% Apply axis label modifications to the current figure
figure(gcf);  % Make sure we're working with the current figure
ax = gca;
xlabel('$X,\, \mathrm{m}$', 'Interpreter', 'latex');
ylabel('$Y,\, \mathrm{m}$', 'Interpreter', 'latex');
zlabel('', 'Interpreter', 'latex')
title('Iter 139 r=30', 'Interpreter', 'latex');
axis equal;
grid on;

% Convert pixel ticks to meter values for x-axis
xticks_pixels = ax.XTick;
xticks_meters = xticks_pixels * 0.25;
xticks(xticks_pixels);
xticklabels(arrayfun(@(x) sprintf('%.1f', x), xticks_meters, 'UniformOutput', false));

% Set y-axis ticks every 10 meters
ylim([0, 365]);  % Set y-axis limits
yticks_meters = 0:10:365;  % Create ticks every 10 meters
yticks_pixels = yticks_meters / 0.25;  % Convert meters to pixels
yticks(yticks_pixels);
yticklabels(arrayfun(@(x) sprintf('%.1f', x), yticks_meters, 'UniformOutput', false));

disp(['Length path: ' num2str(length(total_path)/4)])
disp(['Length path 2: ' num2str(trajectory_length)])