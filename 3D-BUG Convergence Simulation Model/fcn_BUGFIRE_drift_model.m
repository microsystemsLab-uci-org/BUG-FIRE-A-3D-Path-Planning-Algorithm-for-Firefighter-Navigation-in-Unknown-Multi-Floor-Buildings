 function [total_path_true, total_path_est, trajectory_length_true, trajectory_length_est, ...
          goal3DReached_true, goal3DReached_est, emergency_trajectory_length_true, ...
          emergency_trajectory_length_est, bug2_trajectory_length_true, bug2_trajectory_length_est, final_pos_true, final_pos_est] = ...
          fcn_BUGFIRE_drift_model(startPoint, goalPoint, visionRadius, visionAngle)
    
    % Initialize output variables 
    goal3DReached_true = false;
    goal3DReached_est = false;
    trajectory_length_true = 0;
    trajectory_length_est = 0;
    emergency_trajectory_length_true = 0;
    emergency_trajectory_length_est = 0;
    bug2_trajectory_length_true = 0;
    bug2_trajectory_length_est = 0;
    total_path_true = [];
    total_path_est = [];
    final_pos_true = [];    
    final_pos_est = [];     

    % Get the screen size
    screenSize = get(0, 'ScreenSize');
    % Calculate 90% of the screen width and height
    width = round(screenSize(3) * 0.9);
    height = round(screenSize(4) * 0.8);

%     emergency_trajectory_length = 0;
    bug2_trajectory_length = 0;
    
    % Calculate the left and bottom coordinates to center the figure
    left = round((screenSize(3) - width) / 2);
    bottom = round((screenSize(4) - height) / 2);
    
    %% Import EG Map
    % Generate the Engineering Gateway 3D map
    maps = generateEGMap3DBUG();
    
    % Hold the current figure to allow overlaying additional plots
    figureHandle = findobj('Type', 'Figure', 'Name', '3D Trajectory MAE UCI');
    set(figureHandle, 'Position', [left, bottom, width, height]);
    if isempty(figureHandle)
        error('The figure generated by generateEGMap3DBUG does not exist. Ensure the function has executed correctly.');
    end

    startHeight = startPoint(3);
    goalHeight = goalPoint(3);
    total_path = [];
    goalReached = false;
    exitStairsNumber = 0;
    
    %% Compute & Display the 3D m-line
    figure(figureHandle);
    hold on;
    
    mLine3D  = homline(startPoint (1), startPoint (2), goalPoint(1), goalPoint(2)); % Calculate the homogeneous line representation of the m-line
    mLine3D  = mLine3D  / norm(mLine3D (1:2)); % Normalize the line
    
    % Get the current axis limits
    axisLimits = axis;
    xMin = axisLimits(1); xMax = axisLimits(2);
    yMin = axisLimits(3); yMax = axisLimits(4);
    
    % Plot 3D m-line
    figure(figureHandle); % Bring the existing figure to the foreground
    hold on;
    
    % 2D and 3D M-Line representation
    if startHeight == goalHeight 
        % If start and goal are on the same floor
        if mLine3D (2) == 0
            % If the line is vertical (infinite slope)
            plot3([startPoint(1) startPoint(1)], [yMin yMax], [startHeight goalHeight], '--', 'Color', '#696969','LineWidth',2);
        else
            % For non-vertical lines
            x = [xMin xMax]';
            y = -[x [1;1]] * [mLine3D(1); mLine3D(3)] / mLine3D(2);
            plot3(x, y, [goalHeight; goalHeight], '--', 'Color', '#696969', 'Linewidth',2);
            axis equal
        end
    else
        % If start and goal are on different floors
        x_proj = linspace(startPoint(1), goalPoint(1), 100);
        y_proj = linspace(startPoint(2), goalPoint(2), 100);
        z_proj = startHeight * ones(size(x_proj));
    
        x = [xMin xMax]';
        y = -[x [1;1]] * [mLine3D(1); mLine3D(3)] / mLine3D(2);
    
        % 1. Plot the horizontal projection on the start level
        plot3(x, y, [startHeight; startHeight], '-.', 'Color', '#A0A0A0', 'Linewidth', 2, 'DisplayName', 'Horizontal Projection');
    
        % 2. Plot the 3D m-line from start to goal
        zLine = linspace(startHeight, goalHeight, 100);
        plot3(x_proj, y_proj, zLine, '-', 'Color', '#696969', 'Linewidth', 2, 'DisplayName', '3D m-line');
    
        % 3. Plot the vertical line from (goal_x, goal_y, start_z) to (goal_x, goal_y, goal_z)
        plot3([goalPoint(1), goalPoint(1)], [goalPoint(2), goalPoint(2)], [startHeight, goalHeight], '-.', 'Color', '#696969', 'Linewidth', 2, 'DisplayName', 'Vertical Line');
    end
    
    % Plot Initial Position on the 3D plot:
    plot3(startPoint (1), startPoint (2), startHeight, 'ko', 'MarkerSize', 6, 'MarkerEdgeColor', 'k', 'MarkerFaceColor', 'g');
    % Plot the Final Position on the 3D Plot:
    plot3(goalPoint(1), goalPoint(2), goalHeight, 'p', 'MarkerSize', 8, 'MarkerFaceColor', 'r', 'MarkerEdgeColor', 'k');
    
    % Track drift offset between floors
    accumulated_drift_offset = [0; 0]; % [dx; dy] in cells
    
    %% 3D BUG algorithm:
    
    % Initialize cumulative drift tracking across all floors
    cumulative_drift_state = struct( ...
        'yaw_err_rad', 0, ...
        'pos_err_m',   [0;0], ...
        'acc_step_m',  0 );
    cumulative_distance = 0; % Total distance traveled across all navigation segments

    % If the startHeight is the same as the goalHeight:
    trajectory_length = 0;

    while true
        % Goal at Same Floor - Navigation
        if startHeight == goalHeight
            switch startHeight
                case 0
                    bug = Bug2_drift_model_ES(maps.grid.floor2, ...
                        'initialDrift', accumulated_drift_offset, ...
                        'initialDriftState', cumulative_drift_state, ...
                        'initialDistance', cumulative_distance);      % create navigation object
                case 100
                    bug = Bug2_drift_model_ES(maps.grid.floor3, ...
                        'initialDrift', accumulated_drift_offset, ...
                        'initialDriftState', cumulative_drift_state, ...
                        'initialDistance', cumulative_distance);      % create navigation object
                case 200
                    bug = Bug2_drift_model_ES(maps.grid.floor4, ...
                        'initialDrift', accumulated_drift_offset, ...
                        'initialDriftState', cumulative_drift_state, ...
                        'initialDistance', cumulative_distance);      % create navigation object
            end

            pause(1);
            fig = figure;
            set(fig, 'Position', [left, bottom, width, height]);
            [path_estimated, path_true, goalReached_est, goalReached_true] = bug.query(startPoint(1:2), goalPoint(1:2), 'animate', true); % animate the path from start to goal

            % Extract final drift state from Bug2
            cumulative_drift_state = bug.getDriftState();
            cumulative_distance = bug.getCumulativeDistance();
            
            % Calculate trajectory lengths for ESTIMATED path
            diff_path_estimated = diff(path_estimated);
            step_distances_estimated = sqrt(sum(diff_path_estimated.^2, 2));
            bug2_path_length_meters_estimated = sum(step_distances_estimated)/4;
            
            % Calculate trajectory lengths for TRUE path
            diff_path_true = diff(path_true);
            step_distances_true = sqrt(sum(diff_path_true.^2, 2));
            bug2_path_length_meters_true = sum(step_distances_true)/4;
            
            % Calculate final position error (endpoint drift)
            final_position_error = norm(path_estimated(end,:)/4 - path_true(end,:)/4); % Convert to meters
            
            % Calculate trajectory length difference
            trajectory_length_difference = abs(bug2_path_length_meters_estimated - bug2_path_length_meters_true);
            
            % Calculate percentage error
            trajectory_error_percentage = (trajectory_length_difference / bug2_path_length_meters_true) * 100;
            
            % Display results
            disp('========== BUG2 TRAJECTORY ANALYSIS ==========');
            fprintf('TRUE trajectory Target Reached?:      %s\n', string(goalReached_true));
            fprintf('Drift trajectory Target Reached?:     %s\n', string(goalReached_est));
            disp(['TRUE trajectory length:      ', num2str(bug2_path_length_meters_true, '%.2f'), ' m']);
            disp(['ESTIMATED trajectory length: ', num2str(bug2_path_length_meters_estimated, '%.2f'), ' m']);
            disp(['Trajectory length difference: ', num2str(trajectory_length_difference, '%.2f'), ' m']);
            disp(['Trajectory error percentage:  ', num2str(trajectory_error_percentage, '%.2f'), ' %']);
            disp(['Final position error (CEP):   ', num2str(final_position_error, '%.2f'), ' m']);
            disp(['Expected drift (Sugar-Cube):  ', num2str(bug2_path_length_meters_true * 0.0053, '%.2f'), ' m']);
            disp('==============================================');

            % Accumulate lengths separately**
            trajectory_length_true = trajectory_length_true + bug2_path_length_meters_true;
            trajectory_length_est = trajectory_length_est + bug2_path_length_meters_estimated;
            bug2_trajectory_length_true = bug2_trajectory_length_true + bug2_path_length_meters_true;
            bug2_trajectory_length_est = bug2_trajectory_length_est + bug2_path_length_meters_estimated;

            if ~isempty(path_estimated) && ~isempty(path_true)
                figure(figureHandle); % Bring the existing figure to the foreground
                hold on;
                switch startHeight
                    case 0
                        plot3(path_estimated(:,1), path_estimated(:,2), ones(size(path_estimated,1), 1)*0, 'g-', 'LineWidth', 2); hold on;
                        plot3(path_true(:,1), path_true(:,2), ones(size(path_true,1), 1)*0, 'b-', 'LineWidth', 2);
                    case 100
                        plot3(path_estimated(:,1), path_estimated(:,2), ones(size(path_estimated,1), 1)*100, 'g-', 'LineWidth', 2); hold on;
                        plot3(path_true(:,1), path_true(:,2), ones(size(path_true,1), 1)*100, 'b-', 'LineWidth', 2);
                    case 200
                        plot3(path_estimated(:,1), path_estimated(:,2), ones(size(path_estimated,1), 1)*200, 'g-', 'LineWidth', 2); hold on;
                        plot3(path_true(:,1), path_true(:,2), ones(size(path_true,1), 1)*200, 'b-', 'LineWidth', 2);
                    otherwise
                        hold off; % Release the hold
                end
            end

            % Set final goal reached flags**
            goal3DReached_true = goalReached_true;
            goal3DReached_est = goalReached_est;

            if ~isempty(path_true)
                final_pos_true = path_true(end, :);  % [x, y] in cells
            end
            if ~isempty(path_estimated)
                final_pos_est = path_estimated(end, :);  % [x, y] in cells
            end
            
            if goalReached_true == false
                disp("The True Robot is trapped, we coudn't find a reachable path to the target.")
                return;
            else
                disp("True Robot Target found!")

                if goalReached_est == false
                    disp("The Drifted ZUPT-aided INS Robot position is trapped, we coudn't find a reachable path to the target.")
                else
                    disp("The Drifted ZUPT-aided INS Robot Reached the Target!")
                end % else

                return;
            end % else
        end
        
        % Goal at Different Floor - Navigation
        if startHeight ~= goalHeight
            % Emergency Stairs Exploration Algorithm here!
            switch startHeight
                case 0
                    bug = emergencyExitExploration_drift_model_ES(maps.grid.floor2, ...
                                       'initialDriftState', cumulative_drift_state, ...
                                       'initialDistance', cumulative_distance);      % create navigation object
                    bug.setSignCellsDirection([maps.emergencySigns.floor2.direction(:)]);
                    bug.setSignCellsLocation([maps.emergencySigns.floor2.location(1,:)', maps.emergencySigns.floor2.location(2,:)',]); 
                    bug.setExitCells([maps.emergencyStairs.floor2(1,:)', maps.emergencyStairs.floor2(2,:)']); % Stop cells - Emergency stair: Indoor & Outdoor [x',y']
                case 100
                    bug = emergencyExitExploration_drift_model_ES(maps.grid.floor3, ...
                                       'initialDriftState', cumulative_drift_state, ...
                                       'initialDistance', cumulative_distance);      % create navigation object
                    bug.setSignCellsDirection([maps.emergencySigns.floor3.direction(:)]);
                    bug.setSignCellsLocation([maps.emergencySigns.floor3.location(1,:)', maps.emergencySigns.floor3.location(2,:)',]); 
                    bug.setExitCells([maps.emergencyStairs.floor3(1,:)', maps.emergencyStairs.floor3(2,:)']); % Stop cells - Emergency stair: Indoor & Outdoor [x',y']
                case 200
                    bug = emergencyExitExploration_drift_model_ES(maps.grid.floor4, ...
                                       'initialDriftState', cumulative_drift_state, ...
                                       'initialDistance', cumulative_distance);      % create navigation object
                    bug.setSignCellsDirection([maps.emergencySigns.floor4.direction(:)]);
                    bug.setSignCellsLocation([maps.emergencySigns.floor4.location(1,:)', maps.emergencySigns.floor4.location(2,:)',]); 
                    bug.setExitCells([maps.emergencyStairs.floor4(1,:)', maps.emergencyStairs.floor4(2,:)']); % Stop cells - Emergency stair: Indoor & Outdoor [x',y']
            end
            
            fig = figure;
            set(fig, 'Position', [left, bottom, width, height]);
            [path_estimated, path_true, goalReached, exitStairsNumber, drift_offset] = bug.query(startPoint, goalPoint, 'animate', true, 'visionRadius', visionRadius, 'visionAngle', visionAngle);  % Run the pathfinding with vision cone
   
            % Extract final drift state from emergency exploration
            cumulative_drift_state = bug.getDriftState();
            cumulative_distance = bug.getCumulativeDistance();
            
            % Calculate trajectory lengths for ESTIMATED path
            diff_path_estimated = diff(path_estimated);
            step_distances_estimated = sqrt(sum(diff_path_estimated.^2, 2));
            emergency_path_length_meters_estimated = sum(step_distances_estimated)/4;
            
            % Calculate trajectory lengths for TRUE path
            diff_path_true = diff(path_true);
            step_distances_true = sqrt(sum(diff_path_true.^2, 2));
            emergency_path_length_meters_true = sum(step_distances_true)/4;

            % Calculate final position error (endpoint drift)
            emergency_final_position_error = norm(path_estimated(end,:)/4 - path_true(end,:)/4); % Convert to meters
            
            % Calculate trajectory length difference
            emergency_trajectory_length_difference = abs(emergency_path_length_meters_estimated - emergency_path_length_meters_true);
            
            % Calculate percentage error
            emergency_trajectory_error_percentage = (emergency_trajectory_length_difference / emergency_path_length_meters_true) * 100;
            
            % Display results
            disp('========== EMERGENCY STAIR TRAJECTORY ANALYSIS ==========');
            disp(['TRUE trajectory length:      ', num2str(emergency_path_length_meters_true, '%.2f'), ' m']);
            disp(['ESTIMATED trajectory length: ', num2str(emergency_path_length_meters_estimated, '%.2f'), ' m']);
            disp(['Trajectory length difference: ', num2str(emergency_trajectory_length_difference, '%.2f'), ' m']);
            disp(['Trajectory error percentage:  ', num2str(emergency_trajectory_error_percentage, '%.2f'), ' %']);
            disp(['Final position error (CEP):   ', num2str(emergency_final_position_error, '%.2f'), ' m']);
            disp(['Expected drift (Sugar-Cube):  ', num2str(emergency_path_length_meters_true * 0.0053, '%.2f'), ' m']);
            disp('==============================================');

            % Accumulate emergency lengths**
            trajectory_length_true = trajectory_length_true + emergency_path_length_meters_true;
            trajectory_length_est = trajectory_length_est + emergency_path_length_meters_estimated;
            emergency_trajectory_length_true = emergency_trajectory_length_true + emergency_path_length_meters_true;
            emergency_trajectory_length_est = emergency_trajectory_length_est + emergency_path_length_meters_estimated;


            % Plot the path trajectory in green at Fig 1
            if ~isempty(path_estimated) && ~isempty(path_true)
                figure(figureHandle); % Bring the existing figure to the foreground
                hold on;
                switch startHeight
                    case 0
                        plot3(path_estimated(:,1), path_estimated(:,2), ones(size(path_estimated,1), 1)*0, 'g-', 'LineWidth', 2); hold on;
                        plot3(path_true(:,1), path_true(:,2), ones(size(path_true,1), 1)*0, 'b-', 'LineWidth', 2);
                    case 100
                        plot3(path_estimated(:,1), path_estimated(:,2), ones(size(path_estimated,1), 1)*100, 'g-', 'LineWidth', 2); hold on;
                        plot3(path_true(:,1), path_true(:,2), ones(size(path_true,1), 1)*100, 'b-', 'LineWidth', 2);
                    case 200
                        plot3(path_estimated(:,1), path_estimated(:,2), ones(size(path_estimated,1), 1)*200, 'g-', 'LineWidth', 2); hold on;
                        plot3(path_true(:,1), path_true(:,2), ones(size(path_true,1), 1)*200, 'b-', 'LineWidth', 2);
                    otherwise
                        hold off; % Release the hold
                end
            end

            % Accumulate drift for next floor
            if ~isempty(drift_offset)
                accumulated_drift_offset = drift_offset;
                disp(['Drift offset at floor transition: dx=' num2str(drift_offset(1)) ', dy=' num2str(drift_offset(2))]);
            end
    
            % Important, organize exitStairsNumber such as the emergency exits
            % that go across all floors (in the generateEGMap3DBUG function)
            if exitStairsNumber == 1 || exitStairsNumber == 2 || exitStairsNumber == 3
                startHeight = goalHeight;
            end
    
            switch startHeight
                case 0
                    if exitStairsNumber > 0 && exitStairsNumber <= size(maps.emergencyStairs.floor2, 2)
                        startPoint = [maps.emergencyStairs.floor2(:, exitStairsNumber)', startHeight];
                    else
                        error("Invalid exitStairsNumber: %d. Ensure emergency stairs logic is correct.", exitStairsNumber);
                    end
                case 100
                    if exitStairsNumber > 0 && exitStairsNumber <= size(maps.emergencyStairs.floor3, 2)
                        startPoint = [maps.emergencyStairs.floor3(:, exitStairsNumber)', startHeight];
                    else
                        error("Invalid exitStairsNumber: %d. Ensure emergency stairs logic is correct.", exitStairsNumber);
                    end
                case 200
                    if exitStairsNumber > 0 && exitStairsNumber <= size(maps.emergencyStairs.floor4, 2)
                        startPoint = [maps.emergencyStairs.floor4(:, exitStairsNumber)', startHeight];
                    else
                        error("Invalid exitStairsNumber: %d. Ensure emergency stairs logic is correct.", exitStairsNumber);
                    end
            end
        end
    end
end

