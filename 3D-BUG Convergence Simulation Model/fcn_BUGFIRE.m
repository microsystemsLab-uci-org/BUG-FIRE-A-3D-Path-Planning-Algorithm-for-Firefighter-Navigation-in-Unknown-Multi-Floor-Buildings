function [total_path, trajectory_length, goal3DReached, emergency_trajectory_length, bug2_trajectory_length] = fcn_BUGFIRE(startPoint, goalPoint, visionRadius, visionAngle)
    goal3DReached = false;
    % Get the screen size
    screenSize = get(0, 'ScreenSize');
    % Calculate 90% of the screen width and height
    width = round(screenSize(3) * 0.9);
    height = round(screenSize(4) * 0.8);

    emergency_trajectory_length = 0;
    bug2_trajectory_length = 0;
    
    % Calculate the left and bottom coordinates to center the figure
    left = round((screenSize(3) - width) / 2);
    bottom = round((screenSize(4) - height) / 2);
    
    %% Import EG Map
    % Generate the Engineering Gateway 3D map
    maps = generateEGMap3DBUG();
    
    % Hold the current figure to allow overlaying additional plots
    figureHandle = findobj('Type', 'Figure', 'Name', '3D Trajectory MAE UCI');
    set(figureHandle, 'Position', [left, bottom, width, height]);
    if isempty(figureHandle)
        error('The figure generated by generateEGMap3DBUG does not exist. Ensure the function has executed correctly.');
    end

    startHeight = startPoint(3);
    goalHeight = goalPoint(3);
    total_path = [];
    goalReached = false;
    exitStairsNumber = 0;
    
    %% Compute & Display the 3D m-line
    figure(figureHandle);
    hold on;
    
    mLine3D  = homline(startPoint (1), startPoint (2), goalPoint(1), goalPoint(2)); % Calculate the homogeneous line representation of the m-line
    mLine3D  = mLine3D  / norm(mLine3D (1:2)); % Normalize the line
    
    % Get the current axis limits
    axisLimits = axis;
    xMin = axisLimits(1); xMax = axisLimits(2);
    yMin = axisLimits(3); yMax = axisLimits(4);
    
    % Plot 3D m-line
    figure(figureHandle); % Bring the existing figure to the foreground
    hold on;
    
    % 2D and 3D M-Line representation
    if startHeight == goalHeight 
        % If start and goal are on the same floor
        if mLine3D (2) == 0
            % If the line is vertical (infinite slope)
            plot3([startPoint(1) startPoint(1)], [yMin yMax], [startHeight goalHeight], '--', 'Color', '#696969','LineWidth',2);
        else
            % For non-vertical lines
            x = [xMin xMax]';
            y = -[x [1;1]] * [mLine3D(1); mLine3D(3)] / mLine3D(2);
            plot3(x, y, [goalHeight; goalHeight], '--', 'Color', '#696969', 'Linewidth',2);
            axis equal
        end
    else
        % If start and goal are on different floors
        x_proj = linspace(startPoint(1), goalPoint(1), 100);
        y_proj = linspace(startPoint(2), goalPoint(2), 100);
        z_proj = startHeight * ones(size(x_proj));
    
        x = [xMin xMax]';
        y = -[x [1;1]] * [mLine3D(1); mLine3D(3)] / mLine3D(2);
    
        % 1. Plot the horizontal projection on the start level
        plot3(x, y, [startHeight; startHeight], '-.', 'Color', '#A0A0A0', 'Linewidth', 2, 'DisplayName', 'Horizontal Projection');
    
        % 2. Plot the 3D m-line from start to goal
        zLine = linspace(startHeight, goalHeight, 100);
        plot3(x_proj, y_proj, zLine, '-', 'Color', '#696969', 'Linewidth', 2, 'DisplayName', '3D m-line');
    
        % 3. Plot the vertical line from (goal_x, goal_y, start_z) to (goal_x, goal_y, goal_z)
        plot3([goalPoint(1), goalPoint(1)], [goalPoint(2), goalPoint(2)], [startHeight, goalHeight], '-.', 'Color', '#696969', 'Linewidth', 2, 'DisplayName', 'Vertical Line');
    end
    
    % Plot Initial Position on the 3D plot:
    plot3(startPoint (1), startPoint (2), startHeight, 'ko', 'MarkerSize', 6, 'MarkerEdgeColor', 'k', 'MarkerFaceColor', 'g');
    % Plot the Final Position on the 3D Plot:
    plot3(goalPoint(1), goalPoint(2), goalHeight, 'p', 'MarkerSize', 8, 'MarkerFaceColor', 'r', 'MarkerEdgeColor', 'k');
    
    
    %% 3D BUG algorithm:
    % If the startHeight is the same as the goalHeight:
    trajectory_length = 0;
    while true
        if startHeight == goalHeight
            switch startHeight
                case 0
                    bug = Bug2_ES(maps.grid.floor2);      % create navigation object
                case 100
                    bug = Bug2_ES(maps.grid.floor3);      % create navigation object
                case 200
                    bug = Bug2_ES(maps.grid.floor4);      % create navigation object
            end
            pause(1);
            fig = figure;
            set(fig, 'Position', [left, bottom, width, height]);
            [path, goalReached] = bug.query(startPoint(1:2), goalPoint(1:2), 'animate', true); % animate the path from start to goal
    %         [path, goalReached] = bug.query(startPoint(1:2), goalPoint(1:2), 'movie', 'bug2_navigation.mp4');
            total_path = vertcat(total_path, path);

            diff_path = diff(path);
            % Calculate Euclidean distance for each step
            step_distances = sqrt(sum(diff_path.^2, 2));
            bug2_path_length_cells = length(path);
            bug2_path_length_meters = sum(step_distances)/4;
            % Sum up all distances to get total trajectory length
            trajectory_length = trajectory_length + bug2_path_length_meters;
            bug2_trajectory_length = bug2_trajectory_length + bug2_path_length_meters;


            if ~isempty(path)
                figure(figureHandle); % Bring the existing figure to the foreground
                hold on;
                switch startHeight
                    case 0
                        plot3(path(:,1), path(:,2), ones(size(path,1), 1)*0, 'g-', 'LineWidth', 2);
                    case 100
                        plot3(path(:,1), path(:,2), ones(size(path,1), 1)*100, 'g-', 'LineWidth', 2);
                    case 200
                        plot3(path(:,1), path(:,2), ones(size(path,1), 1)*200, 'g-', 'LineWidth', 2);
                    otherwise
                        hold off; % Release the hold
                end
            end
            
            if goalReached == false
                disp("Robot is trapped, we coudn't find a reachable path to the target.")
                goal3DReached = false;
                return;
            else
                disp("Target found!")
                goal3DReached = true;
                return;
            end % else
        end
        % If the startHeight is different form the goalHeight:
        if startHeight ~= goalHeight
            % BUG3 Algorithm here!
            switch startHeight
                case 0
                    bug = emergencyExitExploration_ES(maps.grid.floor2);      % create navigation object
                    bug.setSignCellsDirection([maps.emergencySigns.floor2.direction(:)]);
                    bug.setSignCellsLocation([maps.emergencySigns.floor2.location(1,:)', maps.emergencySigns.floor2.location(2,:)',]); 
                    bug.setExitCells([maps.emergencyStairs.floor2(1,:)', maps.emergencyStairs.floor2(2,:)']); % Stop cells - Emergency stair: Indoor & Outdoor [x',y']
                case 100
                    bug = emergencyExitExploration_ES(maps.grid.floor3);      % create navigation object
                    bug.setSignCellsDirection([maps.emergencySigns.floor3.direction(:)]);
                    bug.setSignCellsLocation([maps.emergencySigns.floor3.location(1,:)', maps.emergencySigns.floor3.location(2,:)',]); 
                    bug.setExitCells([maps.emergencyStairs.floor3(1,:)', maps.emergencyStairs.floor3(2,:)']); % Stop cells - Emergency stair: Indoor & Outdoor [x',y']
                case 200
                    bug = emergencyExitExploration_ES(maps.grid.floor4);      % create navigation object
                    bug.setSignCellsDirection([maps.emergencySigns.floor4.direction(:)]);
                    bug.setSignCellsLocation([maps.emergencySigns.floor4.location(1,:)', maps.emergencySigns.floor4.location(2,:)',]); 
                    bug.setExitCells([maps.emergencyStairs.floor4(1,:)', maps.emergencyStairs.floor4(2,:)']); % Stop cells - Emergency stair: Indoor & Outdoor [x',y']
            end
            
            fig = figure;
            set(fig, 'Position', [left, bottom, width, height]);
            [path, goalReached, exitStairsNumber] = bug.query(startPoint, goalPoint, 'animate', true, 'visionRadius', visionRadius, 'visionAngle', visionAngle);  % Run the pathfinding with vision cone
    %         [path, goalReached, exitStairsNumber] = bug.query(startPoint, goalPoint, 'movie', 'bugEmergencyExitExploration.mp4');
            total_path = vertcat(total_path, path);

            diff_path = diff(path);
            % Calculate Euclidean distance for each step
            step_distances = sqrt(sum(diff_path.^2, 2));
            emergency_path_length_cells = length(path);
            emergency_path_length_meters = sum(step_distances)/4;
            % Sum up all distances to get total trajectory length
            trajectory_length = trajectory_length + emergency_path_length_meters;
            emergency_trajectory_length = emergency_trajectory_length + emergency_path_length_meters;
   
            % Plot the path trajectory in green at Fig 1
            if ~isempty(path)
                figure(figureHandle); % Bring the existing figure to the foreground
                hold on;
                switch startHeight
                    case 0
                        plot3(path(:,1), path(:,2), ones(size(path,1), 1)*0, 'g-', 'LineWidth', 2);
                    case 100
                        plot3(path(:,1), path(:,2), ones(size(path,1), 1)*100, 'g-', 'LineWidth', 2);
                    case 200
                        plot3(path(:,1), path(:,2), ones(size(path,1), 1)*200, 'g-', 'LineWidth', 2);
                    otherwise
                        hold off; % Release the hold
                end
            end
    
            % Important, organize exitStairsNumber such as the emergency exits
            % that go across all floors (in the generateEGMap3DBUG function)
            if exitStairsNumber == 1 || exitStairsNumber == 2 || exitStairsNumber == 3
                startHeight = goalHeight;
            end
    
            switch startHeight
                case 0
                    if exitStairsNumber > 0 && exitStairsNumber <= size(maps.emergencyStairs.floor2, 2)
                        startPoint = [maps.emergencyStairs.floor2(:, exitStairsNumber)', startHeight];
                    else
                        error("Invalid exitStairsNumber: %d. Ensure emergency stairs logic is correct.", exitStairsNumber);
                    end
                case 100
                    if exitStairsNumber > 0 && exitStairsNumber <= size(maps.emergencyStairs.floor3, 2)
                        startPoint = [maps.emergencyStairs.floor3(:, exitStairsNumber)', startHeight];
                    else
                        error("Invalid exitStairsNumber: %d. Ensure emergency stairs logic is correct.", exitStairsNumber);
                    end
                case 200
                    if exitStairsNumber > 0 && exitStairsNumber <= size(maps.emergencyStairs.floor4, 2)
                        startPoint = [maps.emergencyStairs.floor4(:, exitStairsNumber)', startHeight];
                    else
                        error("Invalid exitStairsNumber: %d. Ensure emergency stairs logic is correct.", exitStairsNumber);
                    end
            end
        end
    end
end

